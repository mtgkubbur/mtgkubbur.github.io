[
  {
    "objectID": "throun.html",
    "href": "throun.html",
    "title": "Leikmaður",
    "section": "",
    "text": "cubeRecords = transpose(cube_records_data).map(d =&gt; ({\n  ...d,\n  wins: +d.wins,\n  losses: +d.losses,\n  total: +d.total,\n  winrate: +d.winrate\n}))\n\ndata = {\n  const raw = transpose(player_history);\n  return raw.map(d =&gt; ({\n    ...d,\n    date: new Date(d.date),\n    score_median: +d.score_median,\n    score_q25: +d.score_q25,\n    score_q75: +d.score_q75,\n    score_lower: +d.score_lower,\n    score_upper: +d.score_upper,\n    wins: +d.wins,\n    losses: +d.losses,\n    total: +d.total,\n    winRate: +d.total &gt; 0 ? (+d.wins / +d.total) * 100 : 0,\n    gamma_High: d.gamma_High != null ? +d.gamma_High : null,\n    gamma_Medium: d.gamma_Medium != null ? +d.gamma_Medium : null,\n    gamma_Low: d.gamma_Low != null ? +d.gamma_Low : null,\n    gamma_Other: d.gamma_Other != null ? +d.gamma_Other : null\n  }));\n}\n\n// Get sorted unique player names\nplayers = [...new Set(data.map(d =&gt; d.player))].sort((a, b) =&gt;\n  a.localeCompare(b, \"is\")\n)\n\n// Compute placement (rank by score_median descending) per date\nranks = {\n  const byDate = d3.group(data, d =&gt; +d.date);\n  const result = new Map();\n  for (const [dateKey, rows] of byDate) {\n    const sorted = [...rows].sort((a, b) =&gt; b.score_median - a.score_median);\n    sorted.forEach((d, i) =&gt; {\n      result.set(`${d.player}_${dateKey}`, i + 1);\n    });\n  }\n  return result;\n}\n\n// Add rank to each data point\ndataWithRank = data.map(d =&gt; ({\n  ...d,\n  rank: ranks.get(`${d.player}_${+d.date}`) || null\n}))\n\n// Global domains\nxDomain = d3.extent(data, d =&gt; d.date)\n\nyDomain = [\n  d3.min(data, d =&gt; d.score_lower),\n  d3.max(data, d =&gt; d.score_upper)\n]\n\nmaxPlayers = d3.max([...d3.group(data, d =&gt; +d.date).values()], rows =&gt; rows.length)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\nLeikmaður\nÞróun og tölfræði einstakra leikmanna\n\n\n\nviewof selectedPlayer = Inputs.select([\"\", ...players], {\n  label: \"Leikmaður:\",\n  value: \"\",\n  format: d =&gt; d === \"\" ? \"Veldu leikmann...\" : d\n})\n\n\n\n\n\n\n\nplayerData = selectedPlayer === \"\"\n  ? []\n  : dataWithRank\n      .filter(d =&gt; d.player === selectedPlayer)\n      .sort((a, b) =&gt; a.date - b.date)\n\nlatest = playerData.length &gt; 0 ? playerData[playerData.length - 1] : null\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  if (!latest) {\n    return html`&lt;div class=\"empty-state\"&gt;\n      &lt;div class=\"empty-icon\"&gt;&#9876;&lt;/div&gt;\n      &lt;div&gt;Veldu leikmann til að sjá upplýsingar&lt;/div&gt;\n    &lt;/div&gt;`;\n  }\n\n  const cubeTypes = [\n    { key: \"gamma_High\", label: \"High\", color: \"#d3202a\" },\n    { key: \"gamma_Medium\", label: \"Medium\", color: \"#0e68ab\" },\n    { key: \"gamma_Low\", label: \"Low\", color: \"#00733e\" },\n    { key: \"gamma_Other\", label: \"Annað\", color: \"#8b6914\" }\n  ];\n\n  // Find strongest cube type\n  const gammas = cubeTypes\n    .map(c =&gt; ({ ...c, value: latest[c.key] }))\n    .filter(c =&gt; c.value != null);\n  const best = gammas.length &gt; 0\n    ? gammas.reduce((a, b) =&gt; a.value &gt; b.value ? a : b)\n    : null;\n\n  return html`&lt;div class=\"player-summary\"&gt;\n    &lt;div class=\"stat\"&gt;\n      &lt;div class=\"stat-value\" style=\"color: #0e68ab;\"&gt;${latest.score_median}&lt;/div&gt;\n      &lt;div class=\"stat-label\"&gt;ELO&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"stat\"&gt;\n      &lt;div class=\"stat-value\" style=\"color: #d3202a;\"&gt;#${latest.rank}&lt;/div&gt;\n      &lt;div class=\"stat-label\"&gt;Sæti&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"stat\"&gt;\n      &lt;div class=\"stat-value\" style=\"color: #00733e;\"&gt;${latest.winRate.toFixed(0)}%&lt;/div&gt;\n      &lt;div class=\"stat-label\"&gt;Sigurhlutfall&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"stat\"&gt;\n      &lt;div class=\"stat-value\" style=\"color: #8b6914;\"&gt;${latest.total}&lt;/div&gt;\n      &lt;div class=\"stat-label\"&gt;Leikir&lt;/div&gt;\n    &lt;/div&gt;\n    ${best ? html`&lt;div class=\"stat\"&gt;\n      &lt;div class=\"stat-value\" style=\"color: ${best.color};\"&gt;${best.label}&lt;/div&gt;\n      &lt;div class=\"stat-label\"&gt;Sterkustu kubbar&lt;/div&gt;\n    &lt;/div&gt;` : html``}\n  &lt;/div&gt;`;\n}\n\n\n\n\n\n\n\n{\n  if (!latest) return html``;\n\n  const cubeTypes = [\n    { key: \"gamma_High\", cube: \"High\", label: \"High\", color: \"#d3202a\" },\n    { key: \"gamma_Medium\", cube: \"Medium\", label: \"Medium\", color: \"#0e68ab\" },\n    { key: \"gamma_Low\", cube: \"Low\", label: \"Low\", color: \"#00733e\" },\n    { key: \"gamma_Other\", cube: \"Other\", label: \"Annað\", color: \"#8b6914\" }\n  ];\n\n  const records = cubeRecords\n    .filter(d =&gt; d.player === selectedPlayer);\n\n  // Merge gamma + records into unified rows\n  const rows = cubeTypes.map(c =&gt; {\n    const rec = records.find(r =&gt; r.cube === c.cube);\n    const gamma = latest[c.key];\n    return {\n      label: c.label,\n      color: c.color,\n      wins: rec ? rec.wins : 0,\n      losses: rec ? rec.losses : 0,\n      total: rec ? rec.total : 0,\n      winrate: rec ? rec.winrate : null,\n      gamma: gamma != null ? gamma : null\n    };\n  }).filter(r =&gt; r.total &gt; 0 || r.gamma != null);\n\n  if (rows.length === 0) return html``;\n\n  const maxAbs = Math.max(0.15, d3.max(rows, d =&gt; d.gamma != null ? Math.abs(d.gamma) : 0));\n\n  return html`&lt;div class=\"cube-combined-card\"&gt;\n    &lt;div class=\"cube-affinity-title\"&gt;Árangur og styrkur eftir flokkum&lt;/div&gt;\n    &lt;table class=\"cube-combined-table\"&gt;\n      &lt;thead&gt;\n        &lt;tr&gt;\n          &lt;th&gt;&lt;/th&gt;\n          &lt;th&gt;S&lt;/th&gt;\n          &lt;th&gt;T&lt;/th&gt;\n          &lt;th&gt;%&lt;/th&gt;\n          &lt;th&gt;Styrkur&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;/thead&gt;\n      &lt;tbody&gt;\n        ${rows.map(r =&gt; {\n          const barPct = r.gamma != null ? Math.abs(r.gamma) / maxAbs * 40 : 0;\n          const isPositive = r.gamma &gt;= 0;\n          return html`\n          &lt;tr&gt;\n            &lt;td class=\"cube-record-name\"&gt;\n              &lt;span class=\"cube-record-pip\" style=\"background: ${r.color}\"&gt;&lt;/span&gt;\n              ${r.label}\n            &lt;/td&gt;\n            &lt;td&gt;${r.total &gt; 0 ? r.wins : '–'}&lt;/td&gt;\n            &lt;td&gt;${r.total &gt; 0 ? r.losses : '–'}&lt;/td&gt;\n            &lt;td style=\"color: ${r.winrate != null ? (r.winrate &gt;= 50 ? '#00733e' : '#d3202a') : '#5c4f42'}; font-weight: 600\"&gt;${r.winrate != null ? r.winrate + '%' : '–'}&lt;/td&gt;\n            &lt;td class=\"gamma-cell\"&gt;\n              ${r.gamma != null ? html`\n                &lt;div class=\"gamma-bar-inline\"&gt;\n                  &lt;div class=\"gamma-bar-neg-side\"&gt;${!isPositive ? html`&lt;div class=\"gamma-bar-fill\" style=\"width: ${barPct}%; background: #d3202a;\"&gt;&lt;/div&gt;` : html``}&lt;/div&gt;\n                  &lt;div class=\"gamma-bar-mid\"&gt;&lt;/div&gt;\n                  &lt;div class=\"gamma-bar-pos-side\"&gt;${isPositive ? html`&lt;div class=\"gamma-bar-fill\" style=\"width: ${barPct}%; background: #00733e;\"&gt;&lt;/div&gt;` : html``}&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;span class=\"gamma-val\" style=\"color: ${r.gamma &gt;= 0 ? '#00733e' : '#d3202a'}\"&gt;${r.gamma &gt;= 0 ? '+' : ''}${r.gamma.toFixed(2)}&lt;/span&gt;\n              ` : html`&lt;span style=\"color: #5c4f42\"&gt;–&lt;/span&gt;`}\n            &lt;/td&gt;\n          &lt;/tr&gt;`;\n        })}\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n    &lt;div class=\"cube-footnote\"&gt;\n      &lt;strong&gt;High:&lt;/strong&gt; Vintage Cube, Bolti Vintage Cube, Nerva's Cube | &lt;strong&gt;Medium:&lt;/strong&gt; Meta Memories, Modern Stories, Synergy Cube, Bar Cube | &lt;strong&gt;Low:&lt;/strong&gt; Khans Cube, Kaldheim Cube, Old Border Cube, Pauper Cube, Ab Wheel, Horror Cube | &lt;strong&gt;Annað:&lt;/strong&gt; Boltalandið, Genesis, Stone Soup Cube, Super Turbo Time\n    &lt;/div&gt;\n  &lt;/div&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n{\n  if (!latest) return html``;\n\n  const chartStyle = {\n    fontSize: \"13px\",\n    fontFamily: \"'Inter', system-ui, sans-serif\",\n    background: \"transparent\"\n  };\n\n  const xConfig = {\n    type: \"time\",\n    domain: xDomain,\n    label: null,\n    tickFormat: d =&gt; d.toLocaleDateString(\"is-IS\", { day: \"numeric\", month: \"short\" })\n  };\n\n  const eloChart = Plot.plot({\n    width: width, height: 380, marginLeft: 55, marginBottom: 40,\n    style: chartStyle,\n    x: xConfig,\n    y: { label: \"ELO\", domain: yDomain, grid: true },\n    color: {\n      domain: [\"90% bil\", \"50% bil\", \"Miðgildi\"],\n      range: [\"rgba(14,104,171,0.12)\", \"rgba(14,104,171,0.25)\", \"#0e68ab\"],\n      legend: true\n    },\n    marks: [\n      Plot.areaY(playerData, { x: \"date\", y1: \"score_lower\", y2: \"score_upper\", fill: \"rgba(14,104,171,0.12)\", curve: \"monotone-x\" }),\n      Plot.areaY(playerData, { x: \"date\", y1: \"score_q25\", y2: \"score_q75\", fill: \"rgba(14,104,171,0.25)\", curve: \"monotone-x\" }),\n      Plot.lineY(playerData, { x: \"date\", y: \"score_median\", stroke: \"#0e68ab\", strokeWidth: 2.5, curve: \"monotone-x\" }),\n      Plot.dot([latest], { x: \"date\", y: \"score_median\", fill: \"#0e68ab\", r: 4 }),\n      Plot.text([latest], { x: \"date\", y: \"score_median\", text: d =&gt; `${d.score_median}`, dy: -12, fontSize: 13, fontWeight: \"bold\", fill: \"#0e68ab\" })\n    ]\n  });\n\n  const winrateChart = Plot.plot({\n    width: width, height: 360, marginLeft: 55, marginBottom: 40,\n    style: chartStyle,\n    x: xConfig,\n    y: { label: \"Sigurhlutfall (%)\", domain: [0, 100], grid: true },\n    marks: [\n      Plot.ruleY([50], { stroke: \"#d4cfc9\", strokeDasharray: \"4,4\" }),\n      Plot.lineY(playerData, { x: \"date\", y: \"winRate\", stroke: \"#00733e\", strokeWidth: 2.5, curve: \"monotone-x\" }),\n      Plot.dot([latest], { x: \"date\", y: \"winRate\", fill: \"#00733e\", r: 4 }),\n      Plot.text([latest], { x: \"date\", y: \"winRate\", text: d =&gt; `${d.winRate.toFixed(0)}%`, dy: -12, fontSize: 13, fontWeight: \"bold\", fill: \"#00733e\" })\n    ]\n  });\n\n  const placementChart = Plot.plot({\n    width: width, height: 360, marginLeft: 55, marginBottom: 40,\n    style: chartStyle,\n    x: xConfig,\n    y: { label: \"Sæti\", domain: [maxPlayers, 1], grid: true },\n    marks: [\n      Plot.lineY(playerData, { x: \"date\", y: \"rank\", stroke: \"#d3202a\", strokeWidth: 2.5, curve: \"monotone-x\" }),\n      Plot.dot([latest], { x: \"date\", y: \"rank\", fill: \"#d3202a\", r: 4 }),\n      Plot.text([latest], { x: \"date\", y: \"rank\", text: d =&gt; `#${d.rank}`, dy: -12, fontSize: 13, fontWeight: \"bold\", fill: \"#d3202a\" })\n    ]\n  });\n\n  // Cube affinity evolution chart\n  const cubeTypes = [\n    { key: \"gamma_High\", label: \"High\", color: \"#d3202a\" },\n    { key: \"gamma_Medium\", label: \"Medium\", color: \"#0e68ab\" },\n    { key: \"gamma_Low\", label: \"Low\", color: \"#00733e\" },\n    { key: \"gamma_Other\", label: \"Annað\", color: \"#8b6914\" }\n  ];\n\n  // Reshape gamma data to long format for Plot\n  const gammaData = playerData.flatMap(d =&gt;\n    cubeTypes\n      .filter(c =&gt; d[c.key] != null)\n      .map(c =&gt; ({\n        date: d.date,\n        cube: c.label,\n        gamma: d[c.key],\n        color: c.color\n      }))\n  );\n\n  const gammaChart = gammaData.length &gt; 0 ? Plot.plot({\n    width: width, height: 360, marginLeft: 55, marginBottom: 40,\n    style: chartStyle,\n    x: xConfig,\n    y: { label: \"Kubbaáhrif (γ)\", grid: true },\n    color: {\n      domain: cubeTypes.map(c =&gt; c.label),\n      range: cubeTypes.map(c =&gt; c.color),\n      legend: true\n    },\n    marks: [\n      Plot.ruleY([0], { stroke: \"#d4cfc9\", strokeDasharray: \"4,4\" }),\n      Plot.lineY(gammaData, { x: \"date\", y: \"gamma\", stroke: \"cube\", strokeWidth: 2.5, curve: \"monotone-x\" }),\n      // Latest dots for each cube type\n      ...cubeTypes\n        .filter(c =&gt; latest[c.key] != null)\n        .map(c =&gt; Plot.dot([{ date: latest.date, gamma: latest[c.key] }], {\n          x: \"date\", y: \"gamma\", fill: c.color, r: 3.5\n        }))\n    ]\n  }) : null;\n\n  const gamesChart = Plot.plot({\n    width: width, height: 360, marginLeft: 55, marginBottom: 40,\n    style: chartStyle,\n    x: xConfig,\n    y: { label: \"Fjöldi leikja\", domain: [0, d3.max(playerData, d =&gt; d.total) * 1.1 || 10], grid: true },\n    marks: [\n      Plot.lineY(playerData, { x: \"date\", y: \"total\", stroke: \"#8b6914\", strokeWidth: 2.5, curve: \"monotone-x\" }),\n      Plot.dot([latest], { x: \"date\", y: \"total\", fill: \"#8b6914\", r: 4 }),\n      Plot.text([latest], { x: \"date\", y: \"total\", text: d =&gt; `${d.total}`, dy: -12, fontSize: 13, fontWeight: \"bold\", fill: \"#8b6914\" })\n    ]\n  });\n\n  return html`&lt;div class=\"profile-charts\"&gt;\n    &lt;div class=\"chart-row-full\"&gt;\n      &lt;div class=\"cell\"&gt;\n        &lt;div class=\"chart-title\"&gt;ELO-stig&lt;/div&gt;\n        ${eloChart}\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"dashboard-grid\"&gt;\n      &lt;div class=\"cell\"&gt;\n        &lt;div class=\"chart-title\"&gt;Sæti&lt;/div&gt;\n        ${placementChart}\n      &lt;/div&gt;\n      &lt;div class=\"cell\"&gt;\n        &lt;div class=\"chart-title\"&gt;Sigurhlutfall&lt;/div&gt;\n        ${winrateChart}\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"dashboard-grid\"&gt;\n      ${gammaChart ? html`&lt;div class=\"cell\"&gt;\n        &lt;div class=\"chart-title\"&gt;Kubbastyrkur yfir tíma&lt;/div&gt;\n        ${gammaChart}\n      &lt;/div&gt;` : html``}\n      &lt;div class=\"cell\"&gt;\n        &lt;div class=\"chart-title\"&gt;Fjöldi leikja&lt;/div&gt;\n        ${gamesChart}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;`;\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MtG Kubbur",
    "section": "",
    "text": "ELO-stigaröðun\nUppfært 2026-02-19"
  },
  {
    "objectID": "einvigi.html",
    "href": "einvigi.html",
    "title": "Einvígi",
    "section": "",
    "text": "h2h = transpose(h2h_data)\nh2hCube = transpose(h2h_cube_data)\nplayers = player_names\n\neloHistory = {\n  const raw = transpose(elo_history);\n  return raw.map(d =&gt; ({\n    player: d.player,\n    date: new Date(d.date),\n    score_median: +d.score_median\n  }));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\nEinvígi\nBeinn samanburður milli tveggja leikmanna\n\n\n\nviewof player1 = Inputs.select([\"\", ...players], {\n  label: \"Leikmaður 1:\",\n  value: \"\",\n  format: d =&gt; d === \"\" ? \"Veldu leikmann...\" : d\n})\n\nviewof player2 = Inputs.select([\"\", ...players], {\n  label: \"Leikmaður 2:\",\n  value: \"\",\n  format: d =&gt; d === \"\" ? \"Veldu leikmann...\" : d\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  if (player1 === \"\" || player2 === \"\" || player1 === player2) {\n    const msg = player1 === player2 && player1 !== \"\"\n      ? \"Veldu tvo ólíka leikmenn\"\n      : \"Veldu tvo leikmenn til að sjá einvígið\";\n    return html`&lt;div class=\"empty-state\"&gt;\n      &lt;div class=\"empty-icon\"&gt;&#9876;&lt;/div&gt;\n      &lt;div&gt;${msg}&lt;/div&gt;\n    &lt;/div&gt;`;\n  }\n\n  // Find records in both directions: p1→p2 and p2→p1\n  const forward = h2h.filter(d =&gt; d.player1 === player1 && d.player2 === player2);\n  const reverse = h2h.filter(d =&gt; d.player1 === player2 && d.player2 === player1);\n\n  const p1Wins = (forward[0] ? +forward[0].p1_wins : 0) +\n                 (reverse[0] ? (+reverse[0].games - +reverse[0].p1_wins) : 0);\n  const totalGames = (forward[0] ? +forward[0].games : 0) +\n                     (reverse[0] ? +reverse[0].games : 0);\n  const p2Wins = totalGames - p1Wins;\n\n  if (totalGames === 0) {\n    return html`&lt;div class=\"empty-state\"&gt;\n      &lt;div class=\"empty-icon\"&gt;&#10068;&lt;/div&gt;\n      &lt;div&gt;Engir leikir fundust á milli ${player1} og ${player2}&lt;/div&gt;\n    &lt;/div&gt;`;\n  }\n\n  const p1Pct = Math.round((p1Wins / totalGames) * 100);\n  const p2Pct = 100 - p1Pct;\n  const p1Color = p1Wins &gt;= p2Wins ? \"#00733e\" : \"#d3202a\";\n  const p2Color = p2Wins &gt;= p1Wins ? \"#00733e\" : \"#d3202a\";\n\n  // Cube breakdown\n  const cubeForward = h2hCube.filter(d =&gt; d.player1 === player1 && d.player2 === player2);\n  const cubeReverse = h2hCube.filter(d =&gt; d.player1 === player2 && d.player2 === player1);\n\n  const cubeTypes = [...new Set([...cubeForward.map(d =&gt; d.cube), ...cubeReverse.map(d =&gt; d.cube)])].sort();\n  const cubeRows = cubeTypes.map(cube =&gt; {\n    const fwd = cubeForward.find(d =&gt; d.cube === cube);\n    const rev = cubeReverse.find(d =&gt; d.cube === cube);\n    const w1 = (fwd ? +fwd.p1_wins : 0) + (rev ? (+rev.games - +rev.p1_wins) : 0);\n    const total = (fwd ? +fwd.games : 0) + (rev ? +rev.games : 0);\n    return { cube, p1Wins: w1, p2Wins: total - w1, total };\n  });\n\n  return html`\n    &lt;div class=\"h2h-card\"&gt;\n      &lt;div class=\"h2h-header\"&gt;\n        &lt;div class=\"h2h-player\"&gt;\n          &lt;div class=\"h2h-name\"&gt;${player1}&lt;/div&gt;\n          &lt;div class=\"h2h-wins\" style=\"color: ${p1Color}\"&gt;${p1Wins} &lt;span class=\"h2h-wins-label\"&gt;sigrar&lt;/span&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"h2h-vs\"&gt;vs&lt;/div&gt;\n        &lt;div class=\"h2h-player\"&gt;\n          &lt;div class=\"h2h-name\"&gt;${player2}&lt;/div&gt;\n          &lt;div class=\"h2h-wins\" style=\"color: ${p2Color}\"&gt;${p2Wins} &lt;span class=\"h2h-wins-label\"&gt;sigrar&lt;/span&gt;&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=\"h2h-bar-container\"&gt;\n        &lt;div class=\"h2h-bar-fill h2h-bar-p1\" style=\"width: ${p1Pct}%; background: ${p1Color}\"&gt;${p1Pct}%&lt;/div&gt;\n        &lt;div class=\"h2h-bar-fill h2h-bar-p2\" style=\"width: ${p2Pct}%; background: ${p2Color}\"&gt;${p2Pct}%&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=\"h2h-total\"&gt;${totalGames} leikir samtals&lt;/div&gt;\n      ${cubeRows.length &gt; 0 ? html`\n        &lt;div class=\"h2h-cube-breakdown\"&gt;\n          &lt;div class=\"h2h-cube-title\"&gt;Eftir kubbi&lt;/div&gt;\n          &lt;table class=\"h2h-cube-table\"&gt;\n            &lt;thead&gt;\n              &lt;tr&gt;\n                &lt;th&gt;&lt;/th&gt;\n                &lt;th&gt;${player1}&lt;/th&gt;\n                &lt;th&gt;${player2}&lt;/th&gt;\n                &lt;th&gt;Samtals&lt;/th&gt;\n              &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n              ${cubeRows.map(r =&gt; html`\n                &lt;tr&gt;\n                  &lt;td&gt;${r.cube}&lt;/td&gt;\n                  &lt;td style=\"color: ${r.p1Wins &gt;= r.p2Wins ? '#00733e' : '#d3202a'}; font-weight: 600\"&gt;${r.p1Wins}&lt;/td&gt;\n                  &lt;td style=\"color: ${r.p2Wins &gt;= r.p1Wins ? '#00733e' : '#d3202a'}; font-weight: 600\"&gt;${r.p2Wins}&lt;/td&gt;\n                  &lt;td&gt;${r.total}&lt;/td&gt;\n                &lt;/tr&gt;\n              `)}\n            &lt;/tbody&gt;\n          &lt;/table&gt;\n        &lt;/div&gt;\n      ` : html``}\n    &lt;/div&gt;\n  `;\n}\n\n\n\n\n\n\n\n{\n  if (player1 === \"\" || player2 === \"\" || player1 === player2) return html``;\n\n  const p1Map = new Map(\n    eloHistory.filter(d =&gt; d.player === player1).map(d =&gt; [+d.date, d.score_median])\n  );\n  const eloDiff = eloHistory\n    .filter(d =&gt; d.player === player2 && p1Map.has(+d.date))\n    .map(d =&gt; ({ date: d.date, diff: p1Map.get(+d.date) - d.score_median }))\n    .sort((a, b) =&gt; a.date - b.date);\n\n  if (eloDiff.length &lt; 2) return html``;\n\n  const latestPt = eloDiff[eloDiff.length - 1];\n  const latestColor = latestPt.diff &gt;= 0 ? \"#00733e\" : \"#d3202a\";\n\n  const chart = Plot.plot({\n    width: width, height: 280,\n    marginLeft: 55, marginBottom: 35, marginTop: 20,\n    style: { fontSize: \"12px\", fontFamily: \"'Inter', system-ui, sans-serif\", background: \"transparent\" },\n    x: {\n      type: \"time\", label: null,\n      tickFormat: d =&gt; d.toLocaleDateString(\"is-IS\", { day: \"numeric\", month: \"short\" })\n    },\n    y: { label: \"ELO munur\", grid: true },\n    marks: [\n      Plot.ruleY([0], { stroke: \"#d4cfc9\", strokeDasharray: \"4,4\" }),\n      Plot.areaY(eloDiff, {\n        x: \"date\", y1: 0, y2: d =&gt; Math.max(0, d.diff), fill: \"#00733e\", fillOpacity: 0.3, curve: \"monotone-x\"\n      }),\n      Plot.areaY(eloDiff, {\n        x: \"date\", y1: 0, y2: d =&gt; Math.min(0, d.diff), fill: \"#d3202a\", fillOpacity: 0.3, curve: \"monotone-x\"\n      }),\n      Plot.lineY(eloDiff, { x: \"date\", y: \"diff\", stroke: \"#2a1f14\", strokeWidth: 1.5, curve: \"monotone-x\" }),\n      Plot.dot([latestPt], { x: \"date\", y: \"diff\", fill: latestColor, r: 4 }),\n      Plot.text([latestPt], {\n        x: \"date\", y: \"diff\",\n        text: d =&gt; (d.diff &gt; 0 ? \"+\" : \"\") + d.diff,\n        dy: -12, fontSize: 13, fontWeight: \"bold\", fill: latestColor\n      })\n    ]\n  });\n\n  return html`&lt;div class=\"h2h-elo-chart\"&gt;\n    &lt;div class=\"h2h-chart-title\"&gt;ELO-munur yfir tíma&lt;/div&gt;\n    &lt;div class=\"h2h-chart-subtitle\"&gt;${player1} og ${player2}&lt;/div&gt;\n    ${chart}\n    &lt;div class=\"h2h-chart-legend\"&gt;\n      &lt;span class=\"h2h-legend-item\"&gt;\n        &lt;span class=\"h2h-legend-pip\" style=\"background: #00733e\"&gt;&lt;/span&gt;${player1} framar\n      &lt;/span&gt;\n      &lt;span class=\"h2h-legend-item\"&gt;\n        &lt;span class=\"h2h-legend-pip\" style=\"background: #d3202a\"&gt;&lt;/span&gt;${player2} framar\n      &lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;`;\n}"
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Statistical Methods",
    "section": "",
    "text": "The ranking system uses a Bayesian Bradley-Terry model to estimate relative player strength from head-to-head match results. The model has three key components:\n\nTime-varying baseline strength — Player skill evolves over time via an Ornstein-Uhlenbeck process\nAttendance-based mean reversion — Players who show up maintain their ratings; absent players regress toward the mean\nCube effects — Players can be relatively stronger or weaker in specific cube formats"
  },
  {
    "objectID": "methods.html#overview",
    "href": "methods.html#overview",
    "title": "Statistical Methods",
    "section": "",
    "text": "The ranking system uses a Bayesian Bradley-Terry model to estimate relative player strength from head-to-head match results. The model has three key components:\n\nTime-varying baseline strength — Player skill evolves over time via an Ornstein-Uhlenbeck process\nAttendance-based mean reversion — Players who show up maintain their ratings; absent players regress toward the mean\nCube effects — Players can be relatively stronger or weaker in specific cube formats"
  },
  {
    "objectID": "methods.html#the-bradley-terry-model",
    "href": "methods.html#the-bradley-terry-model",
    "title": "Statistical Methods",
    "section": "The Bradley-Terry Model",
    "text": "The Bradley-Terry Model\nFor a match between player \\(i\\) and player \\(j\\), the probability that \\(i\\) wins is:\n\\[\nP(i \\text{ wins}) = \\text{logit}^{-1}(\\alpha_i - \\alpha_j) = \\frac{\\exp(\\alpha_i - \\alpha_j)}{1 + \\exp(\\alpha_i - \\alpha_j)}\n\\]\nwhere \\(\\alpha_k\\) is player \\(k\\)’s strength on the log-odds scale. When \\(\\alpha_i = \\alpha_j\\), win probability is 50%. Each unit difference in \\(\\alpha\\) corresponds to odds ratio of \\(e^1 \\approx 2.7\\) in favor of the stronger player."
  },
  {
    "objectID": "methods.html#temporal-dynamics-ornstein-uhlenbeck-process",
    "href": "methods.html#temporal-dynamics-ornstein-uhlenbeck-process",
    "title": "Statistical Methods",
    "section": "Temporal Dynamics: Ornstein-Uhlenbeck Process",
    "text": "Temporal Dynamics: Ornstein-Uhlenbeck Process\nPlayer strength evolves over time according to an Ornstein-Uhlenbeck (OU) process that combines two forces:\n\nRandom drift — Strength can fluctuate due to practice, form changes, metagame shifts, etc.\nMean reversion — Strength gradually pulls back toward the population average\n\nThe evolution equation is:\n\\[\n\\alpha_{k,t} = \\phi_k(t)^{\\Delta t} \\cdot \\alpha_{k,t-1} + \\sqrt{\\Delta t} \\cdot \\sigma \\cdot z_{k,t}\n\\]\nwhere:\n\n\\(\\Delta t\\) is the time gap (in weeks) since the previous game night\n\\(\\sigma\\) is a shared volatility parameter\n\\(z_{k,t} \\sim \\text{Normal}(0, 1)\\) are standardized innovations\n\\(\\phi_k(t) \\in [0, 1]\\) is the mean-reversion rate, which depends on attendance\n\n\nAttendance-Based Mean Reversion\nThe key innovation is that the mean-reversion rate depends on whether a player attended:\n\\[\n\\phi_k(t) = \\begin{cases}\n\\phi_{\\text{present}} & \\text{if player } k \\text{ played at time } t \\\\\n\\phi_{\\text{absent}} & \\text{if player } k \\text{ was absent}\n\\end{cases}\n\\]\nwhere typically \\(\\phi_{\\text{present}} &gt; \\phi_{\\text{absent}}\\). This creates asymmetric dynamics:\n\nPlayers who attend maintain their ratings (weak mean reversion, \\(\\phi \\approx 1\\))\nPlayers who are absent regress toward the mean faster (stronger mean reversion, smaller \\(\\phi\\))\n\nThis reflects the intuition that if you don’t show up to prove yourself, the system should become more uncertain about your true current strength—and in the Bradley-Terry framework, increased uncertainty manifests as regression toward the mean.\n\n\nHalf-Life Interpretation\nThe half-life tells us how long it takes for a player’s “excess strength” (distance from the mean) to decay by 50%:\n\\[\nt_{1/2} = -\\frac{\\ln(2)}{\\ln(\\phi)}\n\\]\nFor example, if \\(\\phi_{\\text{absent}} = 0.85\\), the half-life is approximately 4 weeks. This means that if a strong player misses a month of cube nights, they lose about half of their rating advantage over the average player."
  },
  {
    "objectID": "methods.html#cube-effects",
    "href": "methods.html#cube-effects",
    "title": "Statistical Methods",
    "section": "Cube Effects",
    "text": "Cube Effects\nSome players are relatively stronger in certain cube formats (e.g., Vintage Cube vs. Pauper Cube). The model captures this with cube-specific effects \\(\\gamma_{k,c}\\):\n\\[\n\\eta_{ijc,t} = \\alpha_{i,t} + \\gamma_{i,c} - \\alpha_{j,t} - \\gamma_{j,c}\n\\]\nwhere \\(\\gamma_{k,c}\\) represents player \\(k\\)’s relative strength in cube format \\(c\\). The cube effects are constrained so that \\(\\sum_c \\gamma_{k,c} = 0\\) for each player, ensuring that \\(\\alpha_{k,t}\\) represents average strength across all cube types.\nCube formats are categorized as:\n\n\n\nCategory\nCubes\n\n\n\n\nHigh\nVintage Cube, Bolti Vintage Cube, Nerva’s Cube\n\n\nMedium\nModern Cube, Synergy Cube, Bar Cube\n\n\nLow\nKhans Cube, Kaldheim Cube, Old Border Cube, Pauper Cube\n\n\nOther\nMiscellaneous cubes\n\n\n\nThe cube effects are treated as static (not time-varying), which is reasonable since a player’s relative affinity for different formats is unlikely to change dramatically week-to-week."
  },
  {
    "objectID": "methods.html#prior-distributions",
    "href": "methods.html#prior-distributions",
    "title": "Statistical Methods",
    "section": "Prior Distributions",
    "text": "Prior Distributions\nThe model uses the following priors:\n\n\n\n\n\n\n\n\nParameter\nPrior\nRationale\n\n\n\n\n\\(\\alpha_0\\)\n\\(\\text{Normal}(0, 1)\\)\nInitial strengths on log-odds scale\n\n\n\\(\\sigma\\)\n\\(\\text{Exponential}(1)\\)\nVolatility; kept moderate\n\n\n\\(\\phi_{\\text{present}}\\)\n\\(\\text{Beta}(15, 1)\\)\nConcentrated near 1 (weak reversion)\n\n\n\\(\\phi_{\\text{absent}}\\)\n\\(\\text{Beta}(2, 2)\\)\nSymmetric, allows stronger reversion\n\n\n\\(\\gamma_{k,c}\\)\n\\(\\text{Normal}(0, 0.3)\\)\nSmall cube effects centered at zero\n\n\n\nThe prior on \\(\\phi_{\\text{present}}\\) being concentrated near 1 reflects the belief that players who consistently show up should maintain their ratings well. The prior on \\(\\phi_{\\text{absent}}\\) is more diffuse, allowing the data to inform how quickly absent players should regress."
  },
  {
    "objectID": "methods.html#score-scale-0-100",
    "href": "methods.html#score-scale-0-100",
    "title": "Statistical Methods",
    "section": "Score Scale (0-100)",
    "text": "Score Scale (0-100)\nFor interpretability, results are displayed on a normalized 0-100 scale rather than raw log-odds or traditional ELO. The normalization is performed within each posterior draw:\n\\[\n\\text{Score}_k = \\frac{\\alpha_k - \\min_j(\\alpha_j)}{\\max_j(\\alpha_j) - \\min_j(\\alpha_j)} \\times 100\n\\]\nThis means:\n\nA score of 100 corresponds to the strongest player (in that posterior sample)\nA score of 0 corresponds to the weakest player (in that posterior sample)\nA score of 50 represents middle-of-the-pack performance\n\nThe advantage of this approach is that scores are always interpretable as “where does this player fall in the distribution of player skill?” regardless of the overall spread of abilities. With an Ornstein-Uhlenbeck mean-reversion process, traditional ELO scores would become compressed toward the mean, making differences harder to interpret.\n\nUncertainty Propagation\nBecause normalization happens within each posterior draw, uncertainty is properly propagated:\n\nIf there’s high certainty about who’s best, the top player’s score distribution will be tightly concentrated near 100\nIf two players are close in skill, both might have score distributions spanning 85-100, reflecting uncertainty about who’s actually stronger\n\nThe reported score intervals (5th and 95th percentiles) capture this uncertainty. Overlapping intervals indicate that the ranking between those players is uncertain."
  },
  {
    "objectID": "methods.html#identifiability",
    "href": "methods.html#identifiability",
    "title": "Statistical Methods",
    "section": "Identifiability",
    "text": "Identifiability\nThe Bradley-Terry model has a location non-identifiability: we can add any constant to all \\(\\alpha_k\\) without changing the likelihood. We handle this by:\n\nConstraining \\(\\alpha_0\\) (initial strengths) to sum to zero\nRe-centering \\(\\alpha_t\\) after each time step to maintain the constraint\n\nThis ensures the mean player strength is always zero on the log-odds scale. The normalized 0-100 score transformation then maps this to an interpretable scale where relative position is clear."
  },
  {
    "objectID": "methods.html#inference",
    "href": "methods.html#inference",
    "title": "Statistical Methods",
    "section": "Inference",
    "text": "Inference\nThe model is fit using Hamiltonian Monte Carlo (HMC) via Stan, called from R using cmdstanr. Default settings:\n\n4 chains\n1,500 warmup iterations\n3,000 sampling iterations\nadapt_delta = 0.9 to reduce divergent transitions\n\nThe high dimensionality (player strengths at each time point plus cube effects) requires careful tuning, but the non-centered parameterization of the OU process helps with sampling efficiency."
  },
  {
    "objectID": "methods.html#model-comparison",
    "href": "methods.html#model-comparison",
    "title": "Statistical Methods",
    "section": "Model Comparison",
    "text": "Model Comparison\nThe model includes generated quantities for leave-one-out cross-validation (LOO-CV) via the loo package. This allows comparison against simpler alternatives:\n\nStatic Bradley-Terry — No temporal dynamics\nOU without attendance effects — Single \\(\\phi\\) for everyone\nNo cube effects — Only time-varying \\(\\alpha\\)"
  },
  {
    "objectID": "methods.html#limitations-and-future-directions",
    "href": "methods.html#limitations-and-future-directions",
    "title": "Statistical Methods",
    "section": "Limitations and Future Directions",
    "text": "Limitations and Future Directions\nCurrent limitations:\n\nCube effects are static (don’t evolve over time)\nNo player-vs-player specific effects (some players might consistently beat others)\nLimited data per player can lead to high uncertainty\nThe model doesn’t distinguish between “hasn’t played recently” and “new player”\n\nPotential extensions:\n\nGlicko-style uncertainty inflation for inactive players (increase variance rather than shift mean)\nSeparate ranking tables for different cube categories\nTime-varying cube effects\nHierarchical priors on player-specific volatility"
  }
]